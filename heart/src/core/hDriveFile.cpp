/********************************************************************
    Written by James Moran
    Please see the file HEART_LICENSE.txt in the source's root directory.
*********************************************************************/

#include "core/hDriveFile.h"
#include "base/hMemoryUtil.h"

namespace Heart
{

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	hUint64 hDriveFile::Tell()
	{
        if (mmap_) {
            return mmapPos_;
        } else {
            return hdFtell(fileHandle_);
        }
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	hUint64 hDriveFile::Length()
	{
		return size_;
	}

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    hUint32 hDriveFile::Read( void* pBuffer, hUint32 size )
    {
        hUint32 ret;
        if (mmap_) {
            ret=(hUint32)hMin(size, size_-mmapPos_);
            hMemCpy(pBuffer, (hByte*)(hdMMapGetBase(mmap_))+mmapPos_, ret);
            Seek(size, SEEKOFFSET_CURRENT);
        } else {
            if ( hdFread(fileHandle_, pBuffer, size, &ret) != FILEERROR_NONE )
                return 0;
        }
        return ret;
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    hUint32 hDriveFile::Write( const void* pBuffer, hUint32 size )
    {
        hUint32 ret;
        if (mmap_) {
            hcAssertFailMsg("not supported yet...");
        } else {
            if ( hdFwrite(fileHandle_, pBuffer, size, &ret) != FILEERROR_NONE )
                return 0;
        }
        return ret;
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    hUint32 hDriveFile::Seek( hInt64 offset, hdSeekOffset from )
    {
        if (mmap_) {
            switch(from) {
            case SEEKOFFSET_BEGIN:      mmapPos_=offset; break;
            case SEEKOFFSET_CURRENT:    mmapPos_+=offset; break;
            case SEEKOFFSET_END:        mmapPos_=size_+offset; break;
            }
            mmapPos_=hMin(size_, mmapPos_);
        } else {
            hdSeekOffset devFrom = (hdSeekOffset)from;
            hdFseek(fileHandle_, offset, devFrom);
        }
        return 0;
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    hTime hDriveFile::GetTimestamp()
    {
        return stat_.lastModTime_;
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    hBool hDriveFile::getIsMemMapped() const {
        return mmap_ != nullptr;
    }

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    void* hDriveFile::getMemoryMappedBase() const {
        return hdMMapGetBase(mmap_);
    }

}
