/********************************************************************

	filename: 	DeviceOpenGLRenderer.cpp	
	
	Copyright (c) 26:7:2011 James Moran
	
	This software is provided 'as-is', without any express or implied
	warranty. In no event will the authors be held liable for any damages
	arising from the use of this software.
	
	Permission is granted to anyone to use this software for any purpose,
	including commercial applications, and to alter it and redistribute it
	freely, subject to the following restrictions:
	
	1. The origin of this software must not be misrepresented; you must not
	claim that you wrote the original software. If you use this software
	in a product, an acknowledgment in the product documentation would be
	appreciated but is not required.
	
	2. Altered source versions must be plainly marked as such, and must not be
	misrepresented as being the original software.
	
	3. This notice may not be removed or altered from any source
	distribution.

*********************************************************************/

namespace Heart
{

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::Create( Device::Kernel* system, hUint32 width, hUint32 height, hUint32 bpp, hFloat shaderVersion, hBool fullscreen, hBool vsync )
	{
		width_ = width;
		height_ = height;

		if ( fullscreen )
		{
			//TODO: Change the display to match our requested size
		}

		PIXELFORMATDESCRIPTOR pfd=				// pfd Tells Windows How We Want Things To Be
		{
			sizeof(PIXELFORMATDESCRIPTOR),				// Size Of This Pixel Format Descriptor
			1,											// Version Number
			PFD_DRAW_TO_WINDOW |						// Format Must Support Window
			PFD_SUPPORT_OPENGL |						// Format Must Support OpenGL
			PFD_DOUBLEBUFFER,							// Must Support Double Buffering
			PFD_TYPE_RGBA,								// Request An RGBA Format
			(BYTE)bpp,									// Select Our Color Depth
			0, 0, 0, 0, 0, 0,							// Color Bits Ignored
			0,											// No Alpha Buffer
			0,											// Shift Bit Ignored
			0,											// No Accumulation Buffer
			0, 0, 0, 0,									// Accumulation Bits Ignored
			24,											// 24Bit Z-Buffer (Depth Buffer)  
			8,											// 8Bit Stencil Buffer
			0,											// No Auxiliary Buffer
			PFD_MAIN_PLANE,								// Main Drawing Layer
			0,											// Reserved
			0, 0, 0										// Layer Masks Ignored
		};

		pixelFormatDesc_ = pfd;
		hWnd_ = system->GetSystemHandle()->hWnd_;

		ActivateContext();
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::Destroy()
	{
		ReleaseContext();
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::ActivateContext()
	{
		ReleaseContext();

		hDC_ = GetDC( hWnd_ );
		if ( !hDC_ )
		{
			MessageBox( hWnd_, "Couldn't Get Device Context.\nWill now exit.", NULL, MB_OK );
			exit(1);
		}
		pixelFormat_ = ChoosePixelFormat( hDC_, &pixelFormatDesc_ );
		if ( !hDC_ )
		{
			MessageBox( hWnd_, "Couldn't Get Matching Pixel Format.\nWill now exit.", NULL, MB_OK );
			exit(1);
		}
		if ( !SetPixelFormat( hDC_, pixelFormat_, &pixelFormatDesc_ ) )
		{
			MessageBox( hWnd_, "Couldn't Set Matching Pixel Format.\nWill now exit.", NULL, MB_OK );
			exit(1);
		}
		hRC_ = wglCreateContext( hDC_ );
		if ( !hRC_ )
		{
			MessageBox( hWnd_, "Couldn't Create Render Context.\nWill now exit.", NULL, MB_OK );
			exit(1);
		}

		// bind hRC and hDC to this thread.
		wglMakeCurrent( hDC_, hRC_ );

		// init GLEW
		// There may be multi-threading issues here, see GLEW docs.
		glewInit();

		//check we get support for OpenGL 3.1
		if ( !GLEW_VERSION_3_1 )
		{
			MessageBox( hWnd_, "Need support for OpenGL 3.0\nWill now exit.", NULL, MB_OK );
			exit(1);
		}
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::ReleaseContext()
	{
		if ( hRC_ )
		{
			wglMakeCurrent( NULL, NULL );
			wglDeleteContext( hRC_ );
			hRC_ = NULL;
		}

		if ( hDC_ && !ReleaseDC( hWnd_, hDC_ ) )
		{
			hDC_ = NULL;
		}
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::BeginRender()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::EndRender()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::SwapBuffers()
	{
		::SwapBuffers( hDC_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::SetIndexStream( hdOGLIndexBuffer* pIIBuf )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::SetVertexStream( hdOGLVtxBuffer* pIVBuf, hdOGLVtxDecl* pDecl )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::SetRenderState( RENDER_STATE, RENDER_STATE_VALUE )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::SetRenderState( RENDER_STATE, hFloat )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::SetVertexFormat( hdOGLVtxDecl* )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::SetTexture( hdOGLTexture* pTexture, hUint32 idx )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::SetRenderTarget( hUint32 idx , hdOGLTexture* pTarget )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::SetDepthSurface( hdOGLTexture* pSurface )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::SetViewport( const hViewport& viewport )
	{
		glViewport( (GLint)viewport.x_, (GLint)viewport.y_, viewport.width_, viewport.height_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::SetScissorRect( const ScissorRect& scissor )
	{
		glScissor( scissor.left_, scissor.top_, scissor.right_-scissor.left_, scissor.bottom_-scissor.top_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::ClearTarget( hBool clearColour, hColour& colour, hBool clearZ, hFloat z )
	{
		GLbitfield clearflags = GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT;
		clearflags |= clearZ ? GL_DEPTH_BUFFER_BIT : 0;
		glClearDepth( z );
		glClearColor( colour.r_, colour.g_, colour.b_, colour.a_ );
		glClear( clearflags );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::DrawPrimitive( hUint32 nPrimatives )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::DrawVertexStream( PrimitiveType primType )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	CompiledShaderResource* hdOGLRenderer::CompileShader( const hChar* shaderProg, hUint32 len )
	{
		return NULL;
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::ReleaseCompiledShader( CompiledShaderResource* shader )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::GetVertexStrideOffset( hUint32 vtxFlags, hUint32& stride, hUint32* pOffsets )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::CreateVertexDeclaration( hdOGLVtxDecl* ppOut, hUint32 vtxFlags, hUint32& stride, hUint32* pOffsets )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::DestroyVertexDeclaration( hdOGLVtxDecl* pIVD )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::CreateMaterial( hdOGLMaterial* pIOut, CompiledShaderResource* shader, hColour diffuse, hColour ambient, hColour Emissive, hColour specular, hFloat power )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::OnMaterialLoad( hdOGLMaterial* pIOut, void* pStart )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::DestoryMaterial( hdOGLMaterial* pIOut )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::CreateTexture( hdOGLTexture* pOut, hUint32 width, hUint32 height, hUint32 levels, TextureFormat format )
	{
			
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::DestoryTexture( hdOGLTexture* pOut )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::CreateRenderTarget( hdOGLTexture* pOut, hUint32 width, hUint32 height, TextureFormat format )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::DestroyRenderTarget( hdOGLTexture* pOut )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::CreateIndexBuffer( hdOGLIndexBuffer* pIBuf, hUint16* pIndices, hUint16 nIndices, PrimitiveType primType, hUint32 flags )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::DestoryIndexBuffer( hdOGLIndexBuffer* pIBuf )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::CreateVertexBuffer( hdOGLVtxBuffer* pBuf, hUint32 count, hUint32 formatStride, hUint32 flags )
	{
		glGenVertexArrays( 1, &pBuf->vtxArray_ );
		glGenBuffers( 1, vtxBufferObj_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hdOGLRenderer::DestoryVertexBuffer( hdOGLVtxBuffer* pBuf )
	{

	}

}
