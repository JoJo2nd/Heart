/********************************************************************
    Written by James Moran
    Please see the file HEART_LICENSE.txt in the source's root directory.
*********************************************************************/

#include "precompiled.h"
#include "memlog.h"

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void MemLog::clear()
{
    rootList_.clear();
    markerList_.clear();
    markerStack_.clear();
    nextID_ = 1;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void MemLog::pushMemoryMarker(const char* name)
{
    MemLogMarker newmarker;

    newmarker.setName(name);
    markerList_.push_back(newmarker);
    if (markerStack_.size() > 0) {
        (*markerStack_.rbegin())->addChild(&(*markerList_.rbegin()));
    } else {
        rootList_.push_back(&(*markerList_.rbegin()));
    }
    markerStack_.push_back(&(*markerList_.rbegin()));
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void MemLog::popMemoryMarker()
{
    markerStack_.pop_back();
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void MemLog::logMemoryAlloc(uint64 address, uint64 size, const char* heap, const Callstack& backtrace)
{
    AllocRecord allr;

    allr.address_ = address;
    allr.size_ = size;
    allr.backtrace_ = backtrace;
    allr.heapID_ = 0;//TODO:
    allr.freeID_ = 0;
    allr.uid_ = nextID_;

    (*markerStack_.rbegin())->insertMemAlloc(allr);
    ++nextID_;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void MemLog::logMemoryFree(uint64 address, const char* heap, const Callstack& backtrace)
{
    FreeRecord freer;

    freer.address_ = address;
    freer.heapID_ = 0;//TODO: 
    freer.backtrace_ = backtrace;
    freer.uid_ = nextID_;
    freer.allocID_ = 0;

    for (MarkerStackType::reverse_iterator i = markerStack_.rbegin(), iend = markerStack_.rend(); 
        i != iend; ++i)
    {
        if ((*i)->insertMemFree(freer)) break;
    }
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void MemLog::getAllMemoryLeaks(AllocVectorType* leaksArray)
{
    for (MarkerListType::reverse_iterator i = markerList_.rbegin(), iend = markerList_.rend();
        i != iend; ++i)
    {
        i->getAliveAllocsInclusive(leaksArray);
    }
}
