/********************************************************************
	created:	2009/01/08

	filename: 	Camera.cpp

	author:		James Moran
	
	purpose:	
*********************************************************************/

#include "Common.h"
#include "hCamera.h"
#include "hRenderer.h"
#include "Heart.h"

namespace Heart
{
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	Heart::hMatrix& hCamera::GetViewMatrix()
	{
		if ( IsDirty_ == hTrue )
		{
			DirtyEye_ = CameraPos_;
			DirtyLookAt_ = FocusPoint_;
			DirtyUp_ = Up_;

			ViewMatrix_ = hMatrixFunc::LookAt( DirtyEye_, DirtyLookAt_, DirtyUp_ );

			Frustum_.UpdateFromCamera( DirtyEye_, DirtyLookAt_, DirtyUp_, FOV_, Aspect_, Near_, Far_, isOrtho_ );

			IsDirty_ = hFalse;
		}

		return ViewMatrix_;
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	hCamera::hCamera() :
		pRenderer_( NULL )
	{
		DefaultCamera();
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	hCamera::~hCamera()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hCamera::DefaultCamera()
	{
		Up_ = hVec3( 0.0f, 1.0f, 0.0f );
		FOV_ = hmPI / 4.0f;//45.0f
		ViewMatrix_ = hMatrixFunc::identity();
		isOrtho_ = hFalse;
		FocusPoint_ = hVec3( 0.0f, 0.0f, 0.0f );
		CameraPos_  = hVec3( 0.0f, 0.0f, 10.0f );
		Viewport_.x_ = 0;
		Viewport_.y_ = 0;
		Viewport_.width_ = 800;
		Viewport_.height_ = 600;
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hCamera::SetProjectionParams( hFloat Ratio, hFloat Near, hFloat Far )
	{
		Aspect_ = Ratio;
		Near_ = Near;
		Far_ = Far;
		isOrtho_ = hFalse;

		ProjectionMatrix_ = hMatrixFunc::perspectiveFOV( FOV_, Aspect_, Near_, Far_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void hCamera::SetOrthoParams( hFloat width, hFloat height, hFloat znear, hFloat zfar )
	{
		Aspect_ = width / height;
		Near_ = znear;
		Far_ = zfar;
		isOrtho_ = hTrue;

		ProjectionMatrix_ = hMatrixFunc::orthoProj( width, height, Near_, Far_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	hVec3 hCamera::ProjectTo2D( const hVec3& point )
	{
		hVec4 ret;
		hMatrix view, proj,viewProj;

		view = GetViewMatrix();
		proj = GetProjectionMatrix();
		hVec4 point4( point );
		viewProj = hMatrixFunc::mult( view, proj );
		ret = hMatrixFunc::mult( point4, viewProj ); 
		//hVec3 r2( ((ret.x/ret.w) * Viewport_.width_ / 2), ((ret.y/ret.w) * Viewport_.height_ / 2), ret.z/ret.w );
        hVec3 r2( hVec3Func::div( (hVec3)ret, hVec128SplatW( ret ) ) );
        
        return hVec3Func::componentMult( r2, hVec3( Viewport_.width_ / 2.f, Viewport_.height_ / 2.f, 1.f ) );

	}

}