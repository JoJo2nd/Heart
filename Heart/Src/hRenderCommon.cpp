/********************************************************************
	created:	2009/08/30
	created:	30:8:2009   18:18
	filename: 	hrRenderCommon.cpp	
	author:		James
	
	purpose:	
*********************************************************************/

#include "Common.h"

#ifdef HEART_OLD_RENDER_SUBMISSION

#include "hRenderCommon.h"
#include "Heart.h"
#include "hRenderer.h"
#include "hVertexDeclarations.h"
#include "hAABB.h"
#include "hRenderState.h"
#include "hVertexBuffer.h"
#include "hMesh.h"

namespace Heart
{
namespace Cmd
{

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ClearScreen::ClearScreen( const hColour& clearColour )
	{
		clearColour_ = clearColour;
		size_ = sizeof( ClearScreen );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ClearScreen::~ClearScreen()
	{
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void ClearScreen::Execute( hRenderer* pRenderer_ )
	{
		PRINT_RENDER();
		pRenderer_->RenderStateCache().commit();
		//pRenderer_->ClearTarget( true, hColour( clearColour_.r_, clearColour_.g_, clearColour_.b_, clearColour_.a_ ), true, 1.0f );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ClearDepth::ClearDepth()
	{
		size_ = sizeof( ClearDepth );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ClearDepth::~ClearDepth()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void ClearDepth::Execute( hRenderer* pRenderer_ )
	{
		PRINT_RENDER();
		//pRenderer_->ClearTarget( false, hColour( 0.0f, 0.0f, 0.0f, 0.0f ), true, 1.0f );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	BeginScene::BeginScene()
	{
		size_ = sizeof( BeginScene );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	BeginScene::~BeginScene()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void BeginScene::Execute( hRenderer* pRenderer_ )
	{
		PRINT_RENDER();
		pRenderer_->RenderStateCache().defaultRenderState();
		//pRenderer_->Begin();	
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	EndScene::EndScene()
	{
		size_ = sizeof( EndScene );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	EndScene::~EndScene()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void EndScene::Execute( hRenderer* pRenderer_ )
	{
		PRINT_RENDER();
		pRenderer_->RenderStateCache().EndFrame();
		//pRenderer_->End();
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	FlipBuffers::FlipBuffers()
	{
		size_ = sizeof( FlipBuffers );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	FlipBuffers::~FlipBuffers()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void FlipBuffers::Execute( hRenderer* pRenderer_ )
	{
		PRINT_RENDER();
		//pRenderer_->SwapBuffers();
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetViewMatrix::SetViewMatrix( const Heart::hMatrix* pMat )
	{
		view_ = *pMat;
		size_ = sizeof( SetViewMatrix );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetViewMatrix::~SetViewMatrix()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////	
	void SetViewMatrix::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
		pRenderer->RenderStateCache().viewMatrix( view_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetWorldMatrix::SetWorldMatrix( const Heart::hMatrix* pMat )
	{
		world_ = *pMat;
		size_ = sizeof( SetWorldMatrix );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetWorldMatrix::~SetWorldMatrix()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetWorldMatrix::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
		pRenderer->RenderStateCache().worldMatrix( world_);
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetProjectionMatrix::SetProjectionMatrix( const Heart::hMatrix* pMat )
	{
		projection_ = *pMat;
		size_ = sizeof( SetProjectionMatrix );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetProjectionMatrix::~SetProjectionMatrix()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetProjectionMatrix::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
		pRenderer->RenderStateCache().projectionMatrix( projection_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	DrawPrimative::DrawPrimative( hUint32 nPrimatives ) :
		nPrimatives_( nPrimatives )
	{
		hcAssert( nPrimatives_ > 0 );
		size_ = sizeof( DrawPrimative );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	DrawPrimative::~DrawPrimative()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void DrawPrimative::Execute( hRenderer* pRenderer_ )
	{
		PRINT_RENDER();
		pRenderer_->RenderStateCache().commit();

		//pRenderer_->DrawPrimative( nPrimatives_ );

#ifdef HEART_COLLECT_RENDER_STATS
		++pRenderer_->pFrameStats()->nDrawCalls_;
		pRenderer_->pFrameStats()->nTriangels_ += nPrimatives_;
#endif 
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	DrawVertexStream::DrawVertexStream( hVertexBuffer* vtxBuf, PrimitiveType primType ) :
	vtxBuf_( vtxBuf )
		,primType_( primType )
	{
		size_ = sizeof( DrawVertexStream );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	DrawVertexStream::~DrawVertexStream()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void DrawVertexStream::Execute( hRenderer* renderer )
	{
		PRINT_RENDER();

		//renderer->SetVertexFormat( vtxBuf_->GetVertexDeclaration() );
		//renderer->SetVertexBuffer( vtxBuf_ );
		//renderer->RenderStateCache().commit();
		//renderer->DrawVertexStream( primType_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetStreams::SetStreams( hIndexBuffer* pIBuf, hVertexBuffer* pVBuf ) :
		pIBuf_( pIBuf ),
		pVBuf_( pVBuf )
	{
		size_ = sizeof( SetStreams );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetStreams::~SetStreams()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetStreams::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
		//pRenderer->RenderStateCache().vertexDecl( pVBuf_->GetVertexDeclaration() );
		//pRenderer->RenderStateCache().setIndexStream( pIBuf_ );
		//pRenderer->RenderStateCache().setVertexStream( pVBuf_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetViewport::SetViewport( hViewport viewport ) :
		viewport_( viewport )
	{
		hcAssert( viewport_.width_ > 0 && viewport_.height_ > 0 );
		size_ = sizeof( SetViewport );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetViewport::~SetViewport()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetViewport::Execute( hRenderer* pRenderer_ )
	{
		PRINT_RENDER();
		pRenderer_->RenderStateCache().SetViewport( viewport_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	CommitState::CommitState()
	{
		size_ = sizeof( CommitState );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	CommitState::~CommitState()
	{

	}


	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void CommitState::Execute( hRenderer* pRenderer_ )
	{
		PRINT_RENDER();
		pRenderer_->RenderStateCache().commit();
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetDepthBuffer::SetDepthBuffer( hRenderTargetTexture* pSurface ) :
		pSurface_( pSurface )
	{
		size_ = sizeof( SetDepthBuffer );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetDepthBuffer::~SetDepthBuffer()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetDepthBuffer::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
		//pRenderer->RenderStateCache().commit();
		pRenderer->RenderStateCache().SetDepthSurface( pSurface_ );
		pRenderer->RenderStateCache().commit();
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	BindTexture::BindTexture( hMaterial* pMat, const hShaderParameter* pTexParam, const hResourceHandle< hTextureBase >& pTex ) :
		pTex_( pTex ),
		pMat_( pMat ),
		pTexParam_( pTexParam )
	{
		//pTexParam_->boundTexture_.HasData();
// 		hcAssert( pTexParam_ && pTex_.HasData() && pTexParam_->type_ == MATERIALCONSTTYPE_TEXTURE );
 		size_ = sizeof( BindTexture );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	BindTexture::~BindTexture()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void BindTexture::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
		//pMat_->BindTextureParameter( pTexParam_, pTex_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetVertexDecl::SetVertexDecl( hVertexDeclaration* pDecl ) :
	pVertexDecl_( pDecl )
	{
		size_ = sizeof( SetVertexDecl );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetVertexDecl::~SetVertexDecl()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetVertexDecl::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
		pRenderer->RenderStateCache().vertexDecl( pVertexDecl_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetMaterial::SetMaterial( hMaterial* pMat ) :
		pMat_( pMat )
	{
		//pMat_->Validate();
		size_ = sizeof( SetMaterial );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetMaterial::~SetMaterial()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetMaterial::Execute( hRenderer* pRenderer_ )
	{
		PRINT_RENDER();
		//pMat_->Validate();
		pRenderer_->RenderStateCache().setMaterial( pMat_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	DebugDrawLineList2D::DebugDrawLineList2D( hRenderer* pRenderer, Heart::hVec2* points, hUint32 nLines, hColour colour )
	{
		pVtxDecl_ = pRenderer->pVertexDeclManager()->GetVertexDeclartion( hrVF_XYZ | hrVF_COLOR );

		size_ = sizeof( DebugDrawLineList2D );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	DebugDrawLineList2D::~DebugDrawLineList2D()
	{
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void DebugDrawLineList2D::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
	}

#if 0
	DrawScreenQuad::DrawScreenQuad( Renderer* pRenderer, hiEffect* pEffect, const hChar* techName, TextureBase* pTex ) :
	pEffect_( pEffect ),
		pTexture_( pTex )
	{
		//TODO: DrawScreenQuad
#pragma message ("TODO: DrawScreenQuad")
		// 		hUint32 id = pEffect_->getTechniqueID( techName );
		// 		techHandle_ = pEffect_->techHandle( id );
		// 
		// 		hFloat width = (hFloat)pRenderer->Width();
		// 		hFloat w2 = width * 0.25f;
		// 		hFloat height = (hFloat)pRenderer->Height();
		// 		hFloat h2 = height * 0.25f;
		// 
		// 		pVtxDecl_ = pRenderer->pVertexDeclManager()->getVertexDeclartion( hrVF_XYZ | hrVF_1UV );
		// 
		// 		//first triangle
		// 		//use half texel offset to cope with pixel centre
		// 		hFloat u0 = ( 1.0f / ( pTex->Width() * 0.5f ));
		// 		hFloat v0 = ( 1.0f / ( pTex->Height() * 0.5f ));
		// 		hFloat u1 = 1.0f - ( 1.0f / ( pTex->Width() * 0.5f ));
		// 		hFloat v1 = 1.0f - ( 1.0f / ( pTex->Height() * 0.5f ));
		// 
		// 		points_[ 0 ].pos_ = Vec3( -w2, -h2, 0.5f );
		// 		points_[ 0 ].uv_  = hmVec2( u0, v1 );
		// 
		// 		points_[ 1 ].pos_ = Vec3( -w2, h2, 0.5f );
		// 		points_[ 1 ].uv_  = hmVec2( u0, v0 );
		// 
		// 		points_[ 2 ].pos_ = Vec3( w2, h2, 0.5f );
		// 		points_[ 2 ].uv_  = hmVec2( u1, v0 );
		// 
		// 		//second triangle
		// 		points_[ 3 ].pos_ = Vec3( -w2, -h2, 0.5f );
		// 		points_[ 3 ].uv_  = hmVec2( u0, v1 );
		// 
		// 		points_[ 4 ].pos_ = Vec3( w2, h2, 0.5f );
		// 		points_[ 4 ].uv_  = hmVec2( u1, v0 );
		// 
		// 		points_[ 5 ].pos_ = Vec3( w2, -h2, 0.5f );
		// 		points_[ 5 ].uv_  = hmVec2( u1, v1 );

		size_ = sizeof( DrawScreenQuad );
	}

	void DrawScreenQuad::Execute( Renderer* pRenderer )
	{
		//TODO: DrawScreenQuad::Execute
#pragma message ("TODO: DrawScreenQuad::Execute")
		// 		Matrix proj;
		// 		RenderState* pCache = &pRenderer->RenderState();
		// 
		// 		Matrix::orthoProj( &proj, (hFloat)pRenderer->Width(), (hFloat)pRenderer->Height(), 0.0f, 1.0f );
		// 
		// 		pCache->zTest( hFalse );
		// 		pCache->zWrite( hFalse );
		// 		pCache->setCullMode( hrCM_NONE );
		// 
		// 		pCache->setEffect( pEffect_->pEffect() );
		// 		pCache->setEffectTech( techHandle_ );
		// 		pCache->projectionMatrix( (const D3DXMATRIX*)&proj.d3d_ );
		// 
		// 		pCache->setTexture( 0, pTexture_->pD3DTexture() );
		// 
		// 		pCache->beginTechnique();
		// 		pCache->beginTechniquePass( 0 );
		// 
		// 		pCache->vertexDecl( pVtxDecl_ );
		// 		pCache->commit();
		// 
		// 		/*TODO:*/hcBreak;
		// 		//V( pRenderer->pDevice()->DrawPrimitiveUP( D3DPT_TRIANGLELIST, 2, points_, sizeof( Vtx ) ) );
		// 
		// 		pCache->endTechniquePass();
	}

	void DrawScreenQuad2Tex::Execute( Renderer* pRenderer )
	{
		//TODO: DrawScreenQuad2Tex
#pragma message ("TODO: DrawScreenQuad2Tex")
		// 		Matrix proj;
		// 		RenderState* pCache = &pRenderer->RenderState();
		// 
		// 		Matrix::orthoProj( &proj, (hFloat)pRenderer->Width(), (hFloat)pRenderer->Height(), 0.0f, 1.0f );
		// 
		// 		pCache->zTest( hFalse );
		// 		pCache->zWrite( hFalse );
		// 		pCache->setCullMode( hrCM_NONE );
		// 
		// 		pCache->setEffect( pEffect_->pEffect() );
		// 		pCache->setEffectTech( techHandle_ );
		// 		pCache->projectionMatrix( (const D3DXMATRIX*)&proj.d3d_ );
		// 
		// 		pCache->setTexture( 0, pTexture_->pD3DTexture() );
		// 		pCache->setTexture( 1, pTexture2_->pD3DTexture() );
		// 
		// 		pCache->beginTechnique();
		// 		pCache->beginTechniquePass( 0 );
		// 
		// 		pCache->vertexDecl( pVtxDecl_ );
		// 		pCache->commit();
		// 
		// 		/*TODO:*/hcBreak;
		// 		//V( pRenderer->pDevice()->DrawPrimitiveUP( D3DPT_TRIANGLELIST, 2, points_, sizeof( Vtx ) ) );
		// 
		// 		pCache->endTechniquePass();
	}

	void DebugHoldFrame::Execute( Renderer* pRenderer )
	{
		if ( pRenderer->DebugHoldFrameFlag() == hFalse )
		{
			//feel free to debug frame now
			hcBreak;
		}
		pRenderer->DebugHoldFrameFlag( hTrue );
	}
#endif

#if 0
	DebugDrawLine::DebugDrawLine( Renderer* pRenderer, Heart::Vec3 p1, Heart::Vec3 p2, const Heart::Math::Matrix* m, Colour colour ) :
	colour_( colour )
	{
		// get the vertDecl
		//TODO: DebugDrawLine
#pragma message ("TODO: DebugDrawLine")
		// 		pVertDecl_ = pRenderer->pVertexDeclManager()->GetVertexDeclartion( hrVF_XYZ );
		// 
		// 		points_[ 0 ].x = p1.x;
		// 		points_[ 0 ].y = p1.y;
		// 		points_[ 0 ].z = p1.z;
		// 
		// 		points_[ 1 ].x = p2.x;
		// 		points_[ 1 ].y = p2.y;
		// 		points_[ 1 ].z = p2.z;
		// 
		// 		m_ = *m;
		// 
		// 		size_ = sizeof( DebugDrawLine );
	}

	void DebugDrawLine::Execute( Renderer* pRenderer )
	{
		//TODO: DebugDrawLine
#pragma message ("TODO: DebugDrawLine::Execute")
		// 		RenderStateCache* pCache = &pRenderer->RenderStateCache();
		// 
		// 		pCache->zTest( hTrue );
		// 		pCache->zWrite( hTrue );
		// 
		// 		pCache->setEffect( pRenderer->DebugEffect()->pEffect() );
		// 		pCache->setEffectTech( pRenderer->DebugEffect()->techHandle( pRenderer->DebugEffect()->getTechniqueID( pRenderer->DebugEffectTechniqueName( 0 ) ) ) );
		// 		pCache->vertexDecl( pVertDecl_ );
		// 		pCache->beginTechnique();
		// 		pCache->beginTechniquePass( 0 );
		// 		pCache->worldMatrix( (const D3DXMATRIX*)&m_.d3d_ );
		// 		pCache->currentEffect()->SetFloatArray( "DebugColour", (hFloat*)&colour_, 4 );
		// 		pCache->commit();
		// 
		// 		/*TODO:*/hcBreak;
		// 		//pRenderer->pDevice()->DrawPrimitiveUP( D3DPT_LINELIST, 1, points_, sizeof( D3DXVECTOR3 ) );
		// 
		// 		pCache->endTechniquePass();
	}

	DebugDrawCross::DebugDrawCross( Renderer* pRenderer, Heart::Vec3 pos, const Heart::Matrix* m, hFloat size, Colour colour ) :
	colour_( colour )
	{
		// get the vertDecl
		//TODO: DebugDrawCross
#pragma message ("TODO: DebugDrawCross")
		// 		pVertDecl_ = pRenderer->pVertexDeclManager()->getVertexDeclartion( hrVF_XYZ );
		// 
		// 		m_ = *m;
		// 
		// 		points_[ 0 ].x = pos.x + size * 0.5f;
		// 		points_[ 0 ].y = pos.y;
		// 		points_[ 0 ].z = pos.z;
		// 
		// 		points_[ 1 ].x = pos.x - size * 0.5f;
		// 		points_[ 1 ].y = pos.y;
		// 		points_[ 1 ].z = pos.z;
		// 
		// 		points_[ 2 ].x = pos.x;
		// 		points_[ 2 ].y = pos.y + size * 0.5f;
		// 		points_[ 2 ].z = pos.z;
		// 
		// 		points_[ 3 ].x = pos.x;
		// 		points_[ 3 ].y = pos.y - size * 0.5f;
		// 		points_[ 3 ].z = pos.z;
		// 
		// 		points_[ 4 ].x = pos.x;
		// 		points_[ 4 ].y = pos.y;
		// 		points_[ 4 ].z = pos.z + size * 0.5f;
		// 
		// 		points_[ 5 ].x = pos.x;
		// 		points_[ 5 ].y = pos.y;
		// 		points_[ 5 ].z = pos.z -size * 0.5f;

		size_ = sizeof( DebugDrawCross );
	}

	void DebugDrawCross::Execute( Renderer* pRenderer )
	{
		//#ifdef HEART_DEBUG

		//TODO: DebugDrawCross
#pragma message ("TODO: DebugDrawCross::Execute")
		// 		RenderStateCache* pCache = &pRenderer->RenderStateCache();
		// 
		// 		pCache->zTest( hTrue );
		// 		pCache->zWrite( hTrue );
		// 
		// 		pCache->setEffect( pRenderer->DebugEffect()->pEffect() );
		// 		pCache->setEffectTech( pRenderer->DebugEffect()->techHandle( pRenderer->DebugEffect()->getTechniqueID( pRenderer->DebugEffectTechniqueName( 0 ) ) ) );
		// 		pCache->vertexDecl( pVertDecl_ );
		// 		pCache->beginTechnique();
		// 		pCache->beginTechniquePass( 0 );
		// 		pCache->worldMatrix( (const D3DXMATRIX*)&m_.d3d_ );
		// 		pCache->currentEffect()->SetFloatArray( "DebugColour", (hFloat*)&colour_, 4 );
		// 		pCache->commit();
		// 
		// 		/*TODO:*/hcBreak;
		// 		//pRenderer->pDevice()->DrawPrimitiveUP( D3DPT_LINELIST, 3, points_, sizeof( D3DXVECTOR3 ) );
		// 
		// 		pCache->endTechniquePass();
		//#endif
	}


	DebugDrawAABB::DebugDrawAABB( const Heart::AABB* aabb, Renderer* pRenderer, Colour colour ) :
	colour_( colour )
	{
		// get the vertDecl
		//TODO: DebugDrawAABB
#pragma message ("TODO: DebugDrawAABB")
		/*pVertDecl_ = pRenderer->pVertexDeclManager()->getVertexDeclartion( hrVF_XYZ );*/

		//make the needed points for the AABB
		//////////////////////////////////////////////////////////////////////////
		// aabb top
		//line 1
		//top left, far(+Z)
		// 		points_[ 0 ].x = aabb->c.x - aabb->r[ 0 ];
		// 		points_[ 0 ].y = aabb->c.y + aabb->r[ 1 ];
		// 		points_[ 0 ].z = aabb->c.z + aabb->r[ 2 ];
		// 
		// 		//top left, close(-Z)
		// 		points_[ 1 ].x = aabb->c.x - aabb->r[ 0 ];
		// 		points_[ 1 ].y = aabb->c.y + aabb->r[ 1 ];
		// 		points_[ 1 ].z = aabb->c.z - aabb->r[ 2 ];
		// 
		// 		//line 2
		// 		//top left, close
		// 		points_[ 2 ].x = aabb->c.x - aabb->r[ 0 ];
		// 		points_[ 2 ].y = aabb->c.y + aabb->r[ 1 ];
		// 		points_[ 2 ].z = aabb->c.z - aabb->r[ 2 ];
		// 
		// 		//top right, close
		// 		points_[ 3 ].x = aabb->c.x + aabb->r[ 0 ];
		// 		points_[ 3 ].y = aabb->c.y + aabb->r[ 1 ];
		// 		points_[ 3 ].z = aabb->c.z - aabb->r[ 2 ];
		// 
		// 		//line 3
		// 		//top right, close
		// 		points_[ 4 ].x = aabb->c.x + aabb->r[ 0 ];
		// 		points_[ 4 ].y = aabb->c.y + aabb->r[ 1 ];
		// 		points_[ 4 ].z = aabb->c.z - aabb->r[ 2 ];
		// 
		// 		//top right, far
		// 		points_[ 5 ].x = aabb->c.x + aabb->r[ 0 ];
		// 		points_[ 5 ].y = aabb->c.y + aabb->r[ 1 ];
		// 		points_[ 5 ].z = aabb->c.z + aabb->r[ 2 ];
		// 
		// 		//line 4
		// 		//top right, far
		// 		points_[ 6 ].x = aabb->c.x + aabb->r[ 0 ];
		// 		points_[ 6 ].y = aabb->c.y + aabb->r[ 1 ];
		// 		points_[ 6 ].z = aabb->c.z + aabb->r[ 2 ];
		// 
		// 		//top left, far
		// 		points_[ 7 ].x = aabb->c.x - aabb->r[ 0 ];
		// 		points_[ 7 ].y = aabb->c.y + aabb->r[ 1 ];
		// 		points_[ 7 ].z = aabb->c.z + aabb->r[ 2 ];
		// 
		// 		// aabb top
		// 		//////////////////////////////////////////////////////////////////////////
		// 		//////////////////////////////////////////////////////////////////////////
		// 		// aabb bottom
		// 		//line 1
		// 		//bottom left, far(+Z)
		// 		points_[ 8 ].x = aabb->c.x - aabb->r[ 0 ];
		// 		points_[ 8 ].y = aabb->c.y - aabb->r[ 1 ];
		// 		points_[ 8 ].z = aabb->c.z + aabb->r[ 2 ];
		// 
		// 		//bottom left, close(-Z)
		// 		points_[ 9 ].x = aabb->c.x - aabb->r[ 0 ];
		// 		points_[ 9 ].y = aabb->c.y - aabb->r[ 1 ];
		// 		points_[ 9 ].z = aabb->c.z - aabb->r[ 2 ];
		// 
		// 		//line 2
		// 		//bottom left, close
		// 		points_[ 10 ].x = aabb->c.x - aabb->r[ 0 ];
		// 		points_[ 10 ].y = aabb->c.y - aabb->r[ 1 ];
		// 		points_[ 10 ].z = aabb->c.z - aabb->r[ 2 ];
		// 
		// 		//bottom right, close
		// 		points_[ 11 ].x = aabb->c.x + aabb->r[ 0 ];
		// 		points_[ 11 ].y = aabb->c.y - aabb->r[ 1 ];
		// 		points_[ 11 ].z = aabb->c.z - aabb->r[ 2 ];
		// 
		// 		//line 3
		// 		//bottom right, close
		// 		points_[ 12 ].x = aabb->c.x + aabb->r[ 0 ];
		// 		points_[ 12 ].y = aabb->c.y - aabb->r[ 1 ];
		// 		points_[ 12 ].z = aabb->c.z - aabb->r[ 2 ];
		// 
		// 		//bottom right, far
		// 		points_[ 13 ].x = aabb->c.x + aabb->r[ 0 ];
		// 		points_[ 13 ].y = aabb->c.y - aabb->r[ 1 ];
		// 		points_[ 13 ].z = aabb->c.z + aabb->r[ 2 ];
		// 
		// 		//line 4
		// 		//bottom right, far
		// 		points_[ 14 ].x = aabb->c.x + aabb->r[ 0 ];
		// 		points_[ 14 ].y = aabb->c.y - aabb->r[ 1 ];
		// 		points_[ 14 ].z = aabb->c.z + aabb->r[ 2 ];
		// 
		// 		//bottom left, far
		// 		points_[ 15 ].x = aabb->c.x - aabb->r[ 0 ];
		// 		points_[ 15 ].y = aabb->c.y - aabb->r[ 1 ];
		// 		points_[ 15 ].z = aabb->c.z + aabb->r[ 2 ];
		// 
		// 		// aabb bottom
		// 		//////////////////////////////////////////////////////////////////////////
		// 		//////////////////////////////////////////////////////////////////////////
		// 		// aabb sides
		// 		//line 1
		// 		//top right, far
		// 		points_[ 16 ].x = aabb->c.x + aabb->r[ 0 ];
		// 		points_[ 16 ].y = aabb->c.y + aabb->r[ 1 ];
		// 		points_[ 16 ].z = aabb->c.z + aabb->r[ 2 ];
		// 
		// 		//bottom right, far
		// 		points_[ 17 ].x = aabb->c.x + aabb->r[ 0 ];
		// 		points_[ 17 ].y = aabb->c.y - aabb->r[ 1 ];
		// 		points_[ 17 ].z = aabb->c.z + aabb->r[ 2 ];
		// 
		// 		//line 2
		// 		//top right, close
		// 		points_[ 18 ].x = aabb->c.x + aabb->r[ 0 ];
		// 		points_[ 18 ].y = aabb->c.y + aabb->r[ 1 ];
		// 		points_[ 18 ].z = aabb->c.z - aabb->r[ 2 ];
		// 
		// 		//botom right, close
		// 		points_[ 19 ].x = aabb->c.x + aabb->r[ 0 ];
		// 		points_[ 19 ].y = aabb->c.y - aabb->r[ 1 ];
		// 		points_[ 19 ].z = aabb->c.z - aabb->r[ 2 ];
		// 
		// 		//line 3
		// 		//top left, close
		// 		points_[ 20 ].x = aabb->c.x - aabb->r[ 0 ];
		// 		points_[ 20 ].y = aabb->c.y + aabb->r[ 1 ];
		// 		points_[ 20 ].z = aabb->c.z - aabb->r[ 2 ];
		// 
		// 		//bottom left, close
		// 		points_[ 21 ].x = aabb->c.x - aabb->r[ 0 ];
		// 		points_[ 21 ].y = aabb->c.y - aabb->r[ 1 ];
		// 		points_[ 21 ].z = aabb->c.z - aabb->r[ 2 ];
		// 
		// 		//line 4
		// 		//top left, far
		// 		points_[ 22 ].x = aabb->c.x - aabb->r[ 0 ];
		// 		points_[ 22 ].y = aabb->c.y + aabb->r[ 1 ];
		// 		points_[ 22 ].z = aabb->c.z + aabb->r[ 2 ];
		// 
		// 		//bottom left, far
		// 		points_[ 23 ].x = aabb->c.x - aabb->r[ 0 ];
		// 		points_[ 23 ].y = aabb->c.y - aabb->r[ 1 ];
		// 		points_[ 23 ].z = aabb->c.z + aabb->r[ 2 ];

		// aabb sides
		//////////////////////////////////////////////////////////////////////////

		size_ = sizeof( DebugDrawAABB );
	}

	void DebugDrawAABB::Execute( Renderer* pRenderer )
	{
		//TODO: DebugDrawAABB
#pragma message ("TODO: DebugDrawAABB")
		// 		Matrix ident;
		// 		RenderStateCache* pCache = &pRenderer->RenderStateCache();
		// 
		// 		Matrix::identity( &ident );
		// 
		// 		pCache->zTest( hTrue );
		// 		pCache->zWrite( hTrue );
		// 
		// 		pCache->setEffect( pRenderer->DebugEffect()->pEffect() );
		// 		pCache->setEffectTech( pRenderer->DebugEffect()->techHandle( pRenderer->DebugEffect()->getTechniqueID( pRenderer->DebugEffectTechniqueName( 0 ) ) ) );
		// 		pCache->vertexDecl( pVertDecl_ );
		// 		pCache->beginTechnique();
		// 		pCache->beginTechniquePass( 0 );
		// 		pCache->worldMatrix( (const D3DXMATRIX*)&ident.d3d_ );
		// 		pCache->currentEffect()->SetFloatArray( "DebugColour", (hFloat*)&colour_, 4 );
		// 		pCache->commit();
		// 
		// 		/*TODO:*/hcBreak;
		// 		//pRenderer->pDevice()->DrawPrimitiveUP( D3DPT_LINELIST, 12, points_, sizeof( D3DXVECTOR3 ) );
		// 
		// 		pCache->endTechniquePass();
	}
#endif

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetMaterialFloatParameter::SetMaterialFloatParameter( hMaterial* pMat, const hShaderParameter* param, hFloat f ) :
		parameter_( param )
		,pMat_( pMat )
	{
// 		hcAssertMsg( 
// 			param >= pMat->GetShaderParameter((hUint32)0) && param < pMat->GetShaderParameter((hUint32)0) + pMat->GetShaderParameterCount(), 
// 			"Shader Parameter does not belong to this material" );
		val_ = f;
		size_ = sizeof( SetMaterialFloatParameter );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetMaterialFloatParameter::~SetMaterialFloatParameter()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetMaterialFloatParameter::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
		//pMat_->SetFloatArrayParameter( parameter_, &val_, 1 );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetMaterialFloat3Parameter::SetMaterialFloat3Parameter( hMaterial* pMat, const hShaderParameter* param, const hFloat* f ) :
		pMat_( pMat )
		,parameter_( param )
	{
		hcAssertMsg( 
			param >= pMat->GetShaderParameter((hUint32)0) && param < pMat->GetShaderParameter((hUint32)0) + (pMat->GetShaderParameterCount()-1), 
			"Shader Parameter does not belong to this material" );
		memcpy( val_, f, sizeof( hFloat )*3 );
		size_ = sizeof( SetMaterialFloat3Parameter );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetMaterialFloat3Parameter::~SetMaterialFloat3Parameter()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetMaterialFloat3Parameter::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
		//pMat_->SetFloatArrayParameter( parameter_, val_, 3 );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetMaterialColorParameter::SetMaterialColorParameter( hMaterial* pMat, const hShaderParameter* param, const hColour& f ) :
		parameter_( param )
		,pMat_( pMat )
	{
		hcAssertMsg( 
			param >= pMat->GetShaderParameter((hUint32)0) && param < pMat->GetShaderParameter((hUint32)0) + (pMat->GetShaderParameterCount()-1), 
			"Shader Parameter does not belong to this material" );
		memcpy( floatArray_, &f, sizeof( hFloat )*4 );
		size_ = sizeof( SetMaterialColorParameter );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetMaterialColorParameter::~SetMaterialColorParameter()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetMaterialColorParameter::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
		//pMat_->SetFloatArrayParameter( parameter_, floatArray_, 4 );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetMaterialFloat4x4Parameter::SetMaterialFloat4x4Parameter( 
		hMaterial* pMat, 
		const hShaderParameter* param, 
		const hFloat* f ) :
			parameter_( param )
			,pMat_( pMat )
	{
		hcAssertMsg( 
			param >= pMat->GetShaderParameter((hUint32)0) && param < pMat->GetShaderParameter((hUint32)0) + (pMat->GetShaderParameterCount()-1), 
			"Shader Parameter does not belong to this material" );
		memcpy( val_, f, sizeof( hFloat )*16 );
		size_ = sizeof( SetMaterialFloat4x4Parameter );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetMaterialFloat4x4Parameter::~SetMaterialFloat4x4Parameter()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetMaterialFloat4x4Parameter::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
		//pMat_->SetFloatArrayParameter( parameter_, val_, 16 );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetAlphaBlend::SetAlphaBlend( RENDER_STATE_VALUE enable, RENDER_STATE_VALUE blendFunction, RENDER_STATE_VALUE src, RENDER_STATE_VALUE dst ) :
		enable_( enable )
		,blendFunc_( blendFunction )
		,srcBlend_( src )
		,dstBlend_( dst )
	{
		size_ = sizeof( SetAlphaBlend );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetAlphaBlend::~SetAlphaBlend()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetAlphaBlend::Execute( hRenderer* pRenderer_ )
	{
		PRINT_RENDER();
		hRenderState& rs = pRenderer_->RenderStateCache();
		rs.blendEnable( enable_ );
		rs.blendFunc( blendFunc_ );
		rs.srcBlend( srcBlend_ );
		rs.dstBlend( dstBlend_ );
	}


	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetZTest::SetZTest( RENDER_STATE_VALUE enableTest, RENDER_STATE_VALUE enableWrite, RENDER_STATE_VALUE cmp ) :
		testEnable_( enableTest )
		,writeEnable_( enableWrite )
		,cmp_( cmp )
	{
		size_ = sizeof( SetZTest );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetZTest::~SetZTest()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetZTest::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
		hRenderState& rs = pRenderer->RenderStateCache();
		rs.zTest( testEnable_ );
		rs.zWrite( writeEnable_ );
		rs.zCmpFunc( cmp_ );
	}


	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ReleaseIndexBuffer::ReleaseIndexBuffer( hIndexBuffer* pindexbuffer ) :
		pIndexBuffer_( pindexbuffer )
	{
		size_ = sizeof( ReleaseIndexBuffer );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ReleaseIndexBuffer::~ReleaseIndexBuffer()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void ReleaseIndexBuffer::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
		pRenderer->DestroyIndexBuffer( pIndexBuffer_ );
	}


	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ReleaseVertexBuffer::ReleaseVertexBuffer( hVertexBuffer* pvertexbuffer ) :
		pVertexBuffer_( pvertexbuffer )
	{
		size_ = sizeof( ReleaseVertexBuffer );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ReleaseVertexBuffer::~ReleaseVertexBuffer()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void ReleaseVertexBuffer::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
		pRenderer->DestoryVertexBuffer( pVertexBuffer_ );
	}


	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ReleaseTexture::ReleaseTexture( hTexture* ptex ) :
		pTexture_( (hTextureBase*)ptex )
	{
		size_ = sizeof( ReleaseTexture );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ReleaseTexture::~ReleaseTexture()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void ReleaseTexture::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
		pRenderer->DestroyTexture( pTexture_ );
	}


	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ReleaseRenderTarget::ReleaseRenderTarget( hRenderTargetTexture* ptex ) :
		pTexture_( ptex )
	{
		size_ = sizeof( ReleaseRenderTarget );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ReleaseRenderTarget::~ReleaseRenderTarget()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void ReleaseRenderTarget::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
		pRenderer->DestroyRenderTarget( pTexture_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ReleaseMaterial::ReleaseMaterial( hMaterial* pmat ) :
		pMaterial_( pmat )
	{
		size_ = sizeof( ReleaseMaterial );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ReleaseMaterial::~ReleaseMaterial()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void ReleaseMaterial::Execute( hRenderer* pRenderer )
	{
		PRINT_RENDER();
		pRenderer->DestroyMaterial( pMaterial_ );
	}


	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ReleaseMesh::ReleaseMesh( hMesh* pmesh ) :
		pMesh_( pmesh )
	{
		size_ = sizeof( ReleaseMesh );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ReleaseMesh::~ReleaseMesh()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void ReleaseMesh::Execute( hRenderer* pRenderer )
	{
		delete pMesh_;
		pMesh_ = NULL;
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ReleaseDepthSurface::ReleaseDepthSurface( hRenderTargetTexture* pSurface ) :
		pSurface_( pSurface )
	{
		size_ = sizeof( ReleaseDepthSurface );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	ReleaseDepthSurface::~ReleaseDepthSurface()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void ReleaseDepthSurface::Execute( hRenderer* pRenderer )
	{
		pRenderer->DestroyRenderTarget( pSurface_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

// 	SetCullMode::SetCullMode( RENDER_STATE_VALUE val ) :
// 		cullmode_( val )
// 	{
// 		size_ = sizeof( SetCullMode );
// 	}
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//////////////////////////////////////////////////////////////////////////
// 	//////////////////////////////////////////////////////////////////////////
// 
// 	SetCullMode::~SetCullMode()
// 	{
// 
// 	}
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//////////////////////////////////////////////////////////////////////////
// 	//////////////////////////////////////////////////////////////////////////
// 
// 	void SetCullMode::Execute( Renderer* prenderer )
// 	{
// 		prenderer->RenderStateCache().setCullMode( cullmode_ );
// 	}
// 

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

// 	SetWireframeMode::SetWireframeMode( RENDER_STATE_VALUE enable ) :
// 		val_( enable )
// 	{
// 		size_ = sizeof( SetWireframeMode );
// 	}
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//////////////////////////////////////////////////////////////////////////
// 	//////////////////////////////////////////////////////////////////////////
// 
// 	SetWireframeMode::~SetWireframeMode()
// 	{
// 
// 	}
// 
// 	//////////////////////////////////////////////////////////////////////////
// 	//////////////////////////////////////////////////////////////////////////
// 	//////////////////////////////////////////////////////////////////////////
// 
// 	void SetWireframeMode::Execute( Renderer* pRenderer )
// 	{
// 		pRenderer->RenderStateCache().setFillMode( val_ );
// 	}



	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	DrawMesh::DrawMesh( const hMesh* mesh )
	{
		pIBuf_ = mesh->GetIndexBuffer();
		pVBuf_ = mesh->GetVertexBuffer();
		pMat_ = mesh->GetMaterial();
		nPrims_ = mesh->GetPrimativeCount();

		size_ = sizeof( DrawMesh );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	DrawMesh::~DrawMesh()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void DrawMesh::Execute( hRenderer* pRenderer )
	{

	}



	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetRenderTarget::SetRenderTarget( hUint32 idx, hRenderTargetTexture* pTarget ) :
		pTarget_( pTarget )
		,targetIdx_( idx )
	{
		size_ = sizeof( SetRenderTarget );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetRenderTarget::~SetRenderTarget()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetRenderTarget::Execute( hRenderer* pRenderer )
	{
		pRenderer->RenderStateCache().commit();
		//pRenderer->SetRenderTarget( pTarget_, targetIdx_ );
	}



	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	BeginDebuggerEvent::BeginDebuggerEvent( const hChar* name ) :
		name_( name )
	{
		size_ = sizeof( BeginDebuggerEvent );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	BeginDebuggerEvent::~BeginDebuggerEvent()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void BeginDebuggerEvent::Execute( hRenderer* pRenderer )
	{
		//pRenderer->PushDebuggerEvent( name_ );
	}


	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	EndDebuggerEvent::EndDebuggerEvent()
	{
		size_ = sizeof( EndDebuggerEvent );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void EndDebuggerEvent::Execute( hRenderer* pRenderer )
	{
		//pRenderer->PopDebuggerEvent();
	}


	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetFogMode::SetFogMode( hFloat fogstart, hFloat fogend, const hColour& colour ) :
		fogStart_( fogstart )
		,fogEnd_( fogend )
		,fogColour_( colour )
	{
		size_ = sizeof( SetFogMode );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetFogMode::~SetFogMode()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetFogMode::Execute( hRenderer* prenderer )
	{
		prenderer->RenderStateCache().SetFogStart( fogStart_ );
		prenderer->RenderStateCache().SetFogRange( fogEnd_ - fogStart_ );
		prenderer->RenderStateCache().SetFogColour( fogColour_ );

	}


	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////

	CollectRenderStats::CollectRenderStats( hRenderFrameStatsCollection* framestats ) :
		frameStats_( framestats )
	{
		size_ = sizeof( CollectRenderStats );
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////

	CollectRenderStats::~CollectRenderStats()
	{

	}

	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////

	void CollectRenderStats::Execute( hRenderer* pRenderer )
	{
		for ( hUint32 i = 0; i < hRenderFrameStatsCollection::MAX_PASSES; ++i )
		{
			frameStats_->passes_[i].nDrawCalls_ = 0;
			frameStats_->passes_[i].nRenderCmds_ = 0;
			frameStats_->passes_[i].nTriangels_ = 0;
		}
		pRenderer->pFrameStats( frameStats_ );
	}


	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void IncrementRenderStatsPass::Execute( hRenderer* pRenderer )
	{
		pRenderer->NextStatCollectPass();
	}


	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetPointLight::SetPointLight( const hVec3& position, hFloat minR, hFloat maxR, hFloat power, const hColour& diffuse, const hColour& spec, hFloat specExp ) :
		position_( position )
		,minR_( minR )
		,maxR_( maxR )
		,power_( power )
		,diffuse_( diffuse )
		,spec_( spec )
		,specExp_( specExp )
	{
		size_ = sizeof( SetPointLight );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetPointLight::~SetPointLight()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetPointLight::Execute( hRenderer* renderer )
	{
		renderer->RenderStateCache().SetLightPosition( position_ );
		renderer->RenderStateCache().SetLightBrightness( power_ );
		renderer->RenderStateCache().SetLightDiffuse( diffuse_ );
		renderer->RenderStateCache().SetLightSpecular( spec_ );
		renderer->RenderStateCache().SetLightRadius( minR_, maxR_ );
		renderer->RenderStateCache().SetSpecularExponent( specExp_ );
	}


	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetDirectionLight::SetDirectionLight( const hVec3& direction, hFloat power, const hColour& diffuse, const hColour& spec, hFloat specExp ) :
		direction_( direction )
		,power_( power )
		,diffuse_( diffuse )
		,spec_( spec )
		,specExp_( specExp )
	{
		size_ = sizeof( SetDirectionLight );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetDirectionLight::~SetDirectionLight()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetDirectionLight::Execute( hRenderer* renderer )
	{
		renderer->RenderStateCache().SetLightDirection( direction_ );
		renderer->RenderStateCache().SetLightBrightness( power_ );
		renderer->RenderStateCache().SetLightDiffuse( diffuse_ );
		renderer->RenderStateCache().SetLightSpecular( spec_ );
		renderer->RenderStateCache().SetSpecularExponent( specExp_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetSpotLight::SetSpotLight( const hVec3& position, const hVec3& dir, hFloat minR, hFloat maxR, hFloat falloff, hFloat power, const hColour& diffuse, const hColour& spec, hFloat specExp ) :
		position_( position )
		,direction_( dir )
		,power_( power )
		,diffuse_( diffuse )
		,minR_( minR )
		,maxR_( maxR )
		,falloff_( falloff )
		,spec_( spec )
		,specExp_( specExp )
	{
		size_ = sizeof( SetSpotLight );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetSpotLight::~SetSpotLight()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetSpotLight::Execute( hRenderer* renderer )
	{
		renderer->RenderStateCache().SetLightPosition( position_ );
		renderer->RenderStateCache().SetLightDirection( direction_ );
		renderer->RenderStateCache().SetLightBrightness( power_ );
		renderer->RenderStateCache().SetLightDiffuse( diffuse_ );
		renderer->RenderStateCache().SetLightSpecular( spec_ );
		renderer->RenderStateCache().SetSpecularExponent( specExp_ );
		renderer->RenderStateCache().SetLightFalloff( falloff_ );
		renderer->RenderStateCache().SetLightRadius( minR_, maxR_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetScissorTest::SetScissorTest( hBool enable, ScissorRect* rect ) :
		enable_( enable )
	{
		if ( enable_ )
		{
			hcAssert( rect );
			rect_ = *rect;
		}
		size_ = sizeof( SetScissorTest );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	SetScissorTest::~SetScissorTest()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void SetScissorTest::Execute( hRenderer* renderer )
	{
		renderer->RenderStateCache().setScissorTest( enable_ ? RSV_ENABLE : RSV_DISABLE );
		if ( enable_ )
		{
			renderer->RenderStateCache().setScissorRect( rect_ );
		}
	}



	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	FlushVertexBufferData::FlushVertexBufferData( hVertexBuffer* vertexbuffer, void* data, hUint32 size )
		: vertexBuffer_( vertexbuffer )
		, data_( data )
		, dataSize_( size )
	{
		size_ = sizeof( FlushVertexBufferData );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	FlushVertexBufferData::~FlushVertexBufferData()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void FlushVertexBufferData::Execute( hRenderer* renderer )
	{
		//renderer->Bind( vertexBuffer_ );
		//vertexBuffer_->FlushVertexData( data_, dataSize_ );
		renderer->ReleaseTempRenderMemory( data_ );
	}


	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	FlushIndexBufferData::FlushIndexBufferData( hIndexBuffer* indexbuffer, void* data, hUint32 size )
		: indexBuffer_( indexbuffer )
		, data_( data )
		, dataSize_( size )
	{
		size_ = sizeof( FlushIndexBufferData );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	FlushIndexBufferData::~FlushIndexBufferData()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void FlushIndexBufferData::Execute( hRenderer* renderer )
	{
		//renderer->Bind( indexBuffer_ );
		//indexBuffer_->FlushIndexData( data_, dataSize_ );
		renderer->ReleaseTempRenderMemory( data_ );
	}


	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	FlushTextureLevel::FlushTextureLevel( hTexture* tex, hUint32 level, hUint32 pitch, void* data )
		: tex_( tex )
		, level_( level )
		, pitch_( pitch )
		, data_( data )
	{
		size_ = sizeof( FlushTextureLevel );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	FlushTextureLevel::~FlushTextureLevel()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void FlushTextureLevel::Execute( hRenderer* renderer )
	{
		//renderer->Bind( tex_ );
		//tex_->FlushLevel( level_, pitch_, data_ );
	}

}
}
#endif //HEART_OLD_RENDER_SUBMISSION