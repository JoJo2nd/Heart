/********************************************************************
	created:	2008/08/01
	created:	1:8:2008   13:48
	filename: 	ResourceFileSystem.h
	author:		James Moran
	
	purpose:	
*********************************************************************/

#include "ResourceFileSystem.h"
#include <algorithm>


namespace // namespace to hide different file types
{
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	//TODO: Use Memory Mapped Files instead
	class MemoryFile : public ResourceFile
	{
	public:
		MemoryFile();
		~MemoryFile();

		hUint32			Read( void* pDst, hUint32 bytesToRead );
		hUint32			Tell();
		hUint32			Seek( hInt32 toSeek, SeekOffset seekOff );
		hUint32			Size();
		hUint32			Write( void* pSrc, hUint32 bytesToWrite );
		const hChar*	GetFileName() const { return filename_.c_str(); }

	private:

		static const hUint32 DEFAULT_SIZE = 4 * 1024;

		void			SetMode( FileMode mode ) { mode_ = mode; }
		hBool			Open( const hChar* filename, FileMode mode );
		void			Close();

		FileMode		mode_;
		hByte*			pFileMem_;
		hUint32			actualSize_;
		hUint32			writtenDataSize_;
		hUint32			fPos_;
		hBool			isOpen_;
		std::string		filename_;
	};

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	MemoryFile::MemoryFile() :
		mode_( FILEMODE_MAX )
		,pFileMem_( NULL )
		,actualSize_( 0 )
		,writtenDataSize_( 0 )
		,fPos_( 0 )
		,isOpen_( false )
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	MemoryFile::~MemoryFile()
	{

	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	hBool MemoryFile::Open( const hChar* filename, FileMode mode )
	{
		if ( mode == FILEMODE_WRITE )
		{
			hcAssertMsg( pFileMem_ == NULL, "Resource File System does not support opening a write file twice atm" );
			actualSize_ = DEFAULT_SIZE;
			pFileMem_ = new hByte[ actualSize_ ];
			writtenDataSize_ = 0;
			fPos_ = 0;
			isOpen_ = true;
		}
		else if ( mode == FILEMODE_READ )
		{
			hcAssertMsg( pFileMem_ && writtenDataSize_ > 0, "Incorrectly Reading from an empty file" );
			fPos_ = 0;
			isOpen_ = true;
		}

		mode_ = mode;
		filename_ = filename;

		return hTrue;
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void MemoryFile::Close()
	{
		fPos_ = 0;
		isOpen_ = false;
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	hUint32 MemoryFile::Read( void* pDst, hUint32 bytesToRead )
	{
		hcAssertMsg( mode_ == FILEMODE_READ, "Incorrectly Reading from a Write only file" );

		hUint32 bytesLeft = writtenDataSize_ - fPos_;
		hUint32 bytesRead = bytesLeft < bytesToRead ? bytesLeft : bytesToRead;

		if ( bytesRead > 0 )
		{
			memcpy( pDst, &pFileMem_[ fPos_ ], bytesRead );
			fPos_ += bytesRead;
		}

		return bytesRead;
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	hUint32 MemoryFile::Tell()
	{
		return fPos_;
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	hUint32 MemoryFile::Seek( hInt32 toSeek, SeekOffset seekOff )
	{
		switch ( seekOff )
		{
		case SO_SEEK_CUR:
			fPos_ += toSeek;
			break;
		case SO_SEEK_END:
			fPos_ = writtenDataSize_;
			fPos_ += toSeek;
			break;
		case SO_SEEK_SET:
			fPos_ = toSeek;
			break;
		}
		//check file pointer is in a sane position
		if ( fPos_ > writtenDataSize_ )
		{
			if ( toSeek < 0 )
			{
				fPos_ = 0;
			}
			else
			{
				fPos_ = writtenDataSize_;
			}
		}
		return fPos_;
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	hUint32 MemoryFile::Size()
	{
		return writtenDataSize_;
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	hUint32 MemoryFile::Write( void* pSrc, hUint32 bytesToWrite )
	{
		hcAssertMsg( mode_ == FILEMODE_WRITE, "Incorrectly Writing to a Read only file" );

		if ( ( writtenDataSize_ + bytesToWrite ) > actualSize_ )
		{
			// create new data block rounded to 4K
			hUint32 newactualsize = ALIGNTO_POWER2( writtenDataSize_ + bytesToWrite, 4*1024 );
			hByte* pNewMem = new hByte[ newactualsize ];
			//copy old data
			memcpy( pNewMem, pFileMem_, writtenDataSize_ );
			actualSize_ = newactualsize;
			delete[] pFileMem_;
			pFileMem_ = pNewMem;
		}
	
		memcpy( &pFileMem_[ fPos_ ], pSrc, bytesToWrite );
		fPos_ += bytesToWrite;

		if ( fPos_ > writtenDataSize_ )
		{
			writtenDataSize_ = fPos_;
		}

		return bytesToWrite;
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	class FileSystemFile : public ResourceFile
	{
	public:
		FileSystemFile();
		~FileSystemFile();

		hUint32			Read( void* pDst, hUint32 bytesToRead );
		hUint32			Tell();
		hUint32			Seek( hInt32 toSeek, SeekOffset seekOff );
		hUint32			Size();
		hUint32			Write( void* pSrc, hUint32 bytesToWrite );
		const hChar*	GetFileName() const { return filename_.c_str(); }

	private:

		void			SetMode( FileMode mode ) { mode_ = mode; }
		hBool			Open( const hChar* filename, FileMode mode );
		void			Close();

		FILE*			pFile_;
		FileMode		mode_;
		std::string		filename_;
	};

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	FileSystemFile::FileSystemFile() :
		pFile_( NULL )
		,mode_( FILEMODE_MAX )
	{
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	FileSystemFile::~FileSystemFile()
	{
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	hBool FileSystemFile::Open( const hChar* filename, FileMode mode )
	{
		if ( mode == FILEMODE_READ )
		{
			pFile_ = fopen( filename, "rb" );
			if ( !pFile_ )
			{
				return hFalse;
			}
			SetMode( mode );
			filename_ = filename;
			return hTrue;
		}
		else if ( mode == FILEMODE_WRITE )
		{
			pFile_ = fopen( filename, "wb" );
			if ( !pFile_ )
			{
				return hFalse;
			}
			SetMode( mode );
			filename_ = filename;
			return hTrue;
		}
		else
		{
			return hFalse;
		}
	}


	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	void FileSystemFile::Close()
	{
		if ( pFile_ )
		{
			fclose( pFile_ );
			pFile_ = NULL;
		}
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	hUint32 FileSystemFile::Read( void* pDst, hUint32 bytesToRead )
	{
		hcAssertMsg( mode_ == FILEMODE_READ, "Incorrectly Reading from a Write only file" );
		return fread( pDst, 1, bytesToRead, pFile_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	hUint32 FileSystemFile::Tell()
	{
		return ftell( pFile_ );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	hUint32 FileSystemFile::Seek( hInt32 toSeek, SeekOffset seekOff )
	{
		int offset;
		switch( seekOff )
		{
		case SO_SEEK_CUR: offset = SEEK_CUR; break;
		case SO_SEEK_SET: offset = SEEK_SET; break;
		case SO_SEEK_END: offset = SEEK_END; break;
		}
		return fseek( pFile_, toSeek, offset );
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	hUint32 FileSystemFile::Size()
	{
		long ppos = ftell( pFile_ );
		fseek( pFile_, 0, SEEK_END );
		long ret = ftell( pFile_ );
		fseek( pFile_, ppos, SEEK_SET );
		return ret;
	}

	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////

	hUint32 FileSystemFile::Write( void* pSrc, hUint32 bytesToWrite )
	{
		hcAssertMsg( mode_ == FILEMODE_WRITE, "Incorrectly Writing to a Read only file" );
		return fwrite( pSrc, bytesToWrite, 1, pFile_ );
	}

}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

ResourceFileSystem::ResourceFileSystem()
{

}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

ResourceFileSystem::~ResourceFileSystem()
{

}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void ResourceFileSystem::Initialise()
{

}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void ResourceFileSystem::CacheData()
{

}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

ResourceFile* ResourceFileSystem::OpenFile( const hChar* filename, FileMode mode )
{
	mutex_.Lock();

	if ( mode == FILEMODE_WRITE )
	{
		//we can only write to memory files
		MemFileList::const_iterator iend = memoryFiles_.end();
		for ( MemFileList::iterator i = memoryFiles_.begin(); i != iend; ++i )
		{
			if ( _strcmpi( (*i)->GetFileName(), filename ) == 0 )
			{
				//found, which is an error really
				mutex_.Unlock();
				return NULL;
			}
		}

		//got here, so not found the file for some other reason 
		//we create it now
		ResourceFile* pRet = new MemoryFile();
		if ( pRet->Open( filename, mode ) )
		{
			memoryFiles_.push_back( pRet );
			mutex_.Unlock();
			return pRet;
		}

		delete pRet;
		mutex_.Unlock();
		return NULL;
	}
	else if ( mode == FILEMODE_READ )
	{
		ResourceFile* pRet = NULL;

		// See if we can find a Memory File version first?
		MemFileList::const_iterator iend = memoryFiles_.end();
		for ( MemFileList::iterator i = memoryFiles_.begin(); i != iend; ++i )
		{
			if ( _strcmpi( (*i)->GetFileName(), filename ) == 0 )
			{
				//found, return this
				pRet = (*i);
				pRet->Open( filename, mode );

				mutex_.Unlock();
				return pRet;
			}
		}

		// open file from the file system
		pRet = new FileSystemFile();
		if ( pRet->Open( filename, mode ) )
		{
			mutex_.Unlock();
			return pRet;
		}

		delete pRet;
		mutex_.Unlock();
		return NULL;
	}

	mutex_.Unlock();
	//unkown read mode?
	return NULL;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

hBool ResourceFileSystem::CloseFile( ResourceFile* pFile )
{
	mutex_.Lock();

	if ( pFile )
	{
		pFile->Close();
		if ( std::find( memoryFiles_.begin(), memoryFiles_.end(), pFile ) == memoryFiles_.end() )
		{
			//was a file system file, so delete it
			delete pFile;
		}
	}

	mutex_.Unlock();

	return hTrue;
}

